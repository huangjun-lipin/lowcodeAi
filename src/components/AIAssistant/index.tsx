import React, { useState, useRef, useEffect } from 'react';
import { Button, Dialog, Input, Message, Loading, Radio, Divider } from '@alifd/next';
import { IPublicModelPluginContext } from '@alilc/lowcode-types';
import { material } from '@alilc/lowcode-engine';
import { generateSchema, generateSchemaWithMaterials, generateSchemaStream, generateSchemaWithMaterialsStream, getAvailableMaterials, getDetailedMaterials, mockGenerateSchema, StreamEvent } from '../../services/aiService';
import { schema as demoSchema } from './demo';
import './index.less';

interface ChatMessage {
  id: string;
  type: 'user' | 'assistant' | 'iteration' | 'streaming';
  content: string;
  timestamp: number;
  iterationData?: {
    iterationNumber: number;
    completed: boolean;
    hasSchema: boolean;
    schemaSize: number;
    reasoning?: string;
  };
  isStreaming?: boolean;
  streamingComplete?: boolean;
  finalSchema?: any;
  finalResult?: any;
}

interface AIAssistantProps {
  ctx: IPublicModelPluginContext;
}

type AIMode = 'standard' | 'smart-materials';

const AIAssistant: React.FC<AIAssistantProps> = ({ ctx }) => {
  const [visible, setVisible] = useState(false);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [loading, setLoading] = useState(false);
  const [aiMode, setAiMode] = useState<AIMode>('standard');
  const [conversationEnded, setConversationEnded] = useState(false);
  const [pendingSchemas, setPendingSchemas] = useState<any[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const lastUpdateTimeRef = useRef<number>(0); // ‰ΩøÁî®refÊù•Â≠òÂÇ®‰∏äÊ¨°Êõ¥Êñ∞Êó∂Èó¥

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const updateStreamingMessage = (messageId: string, content: string, complete: boolean = false, schema?: any, result?: any) => {
    setMessages(prev => prev.map(msg => 
      msg.id === messageId 
        ? { 
            ...msg, 
            content, 
            streamingComplete: complete,
            finalSchema: schema || msg.finalSchema,
            finalResult: result || msg.finalResult
          }
        : msg
    ));
  };

  const addIterationMessage = (messageId: string, iterationData: any) => {
    const iterationMessage: ChatMessage = {
      id: `${messageId}_iteration_${iterationData.iterationNumber}`,
      type: 'iteration',
      content: `Á¨¨ ${iterationData.iterationNumber} Ê¨°Ëø≠‰ª£${iterationData.completed ? ' (Â∑≤ÂÆåÊàê)' : ' (ËøõË°å‰∏≠)'}`,
      timestamp: Date.now(),
      iterationData,
    };
    
    setMessages(prev => [...prev, iterationMessage]);
  };

  // Â∫îÁî®ÊâÄÊúâÂæÖÂ§ÑÁêÜÁöÑschemaÂà∞ÁºñËæëÂô®
  const applyPendingSchemasToEditor = () => {
    if (pendingSchemas.length === 0) return;

    try {
      // ‰ΩøÁî®ÊúÄÂêé‰∏Ä‰∏™schemaÔºàÊúÄÊñ∞ÁöÑÁªìÊûúÔºâ
      const latestSchema = pendingSchemas[pendingSchemas.length - 1];
      
      // ÂÖàÊ£ÄÊü•ÊòØÂê¶ÊúâÊâìÂºÄÁöÑÊñáÊ°£ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂàõÂª∫‰∏Ä‰∏™
      let currentDocument = ctx.project.getCurrentDocument();
      if (!currentDocument) {
        console.log('Ê≤°ÊúâÊâìÂºÄÁöÑÊñáÊ°£ÔºåÂàõÂª∫Êñ∞ÊñáÊ°£...');
        currentDocument = ctx.project.openDocument({
          componentName: 'Page',
          fileName: 'ai-generated-page',
        });
      }
      
      // ÊûÑÂª∫Ê≠£Á°ÆÁöÑÈ°πÁõÆschemaÁªìÊûÑ
      const projectSchema = {
        componentsTree: [latestSchema],
        componentsMap: material.componentsMap as any,
        version: '1.0.0',
        i18n: {},
      };
      
      console.log('ÂáÜÂ§áÂØºÂÖ•ÁöÑÈ°πÁõÆschema:', projectSchema);
      
      // ÂØºÂÖ•schemaÂà∞È°πÁõÆ
      ctx.project.importSchema(projectSchema as any);
      
      // Ëß¶ÂèëÈáçÊñ∞Ê∏≤Êüì
      ctx.project.simulatorHost?.rerender();
      
      console.log('SchemaÂØºÂÖ•ÊàêÂäü');
      Message.success('È°µÈù¢Â∑≤Â∫îÁî®Âà∞ÁºñËæëÂô®ÔºÅ');
      
      // Ê∏ÖÁ©∫ÂæÖÂ§ÑÁêÜÁöÑschemas
      setPendingSchemas([]);
    } catch (error) {
      console.error('Â∫îÁî®schemaÂà∞ÁºñËæëÂô®Â§±Ë¥•:', error);
      Message.error('Â∫îÁî®Âà∞ÁºñËæëÂô®Â§±Ë¥•');
    }
  };

  // ÁªìÊùüÂØπËØùÂπ∂Â∫îÁî®ÁªìÊûú
  const endConversationAndApply = () => {
    setConversationEnded(true);
    applyPendingSchemasToEditor();
    
    // Ê∑ªÂä†ÁªìÊùüÂØπËØùÁöÑÊ∂àÊÅØ
    const endMessage: ChatMessage = {
      id: `end_${Date.now()}`,
      type: 'assistant',
      content: 'üéâ ÂØπËØùÂ∑≤ÁªìÊùüÔºåÁîüÊàêÁöÑÈ°µÈù¢Â∑≤Â∫îÁî®Âà∞ÁºñËæëÂô®‰∏≠ÔºÅ',
      timestamp: Date.now(),
    };
    
    setMessages(prev => [...prev, endMessage]);
  };

  const handleSendMessage = async () => {
    if (!inputValue.trim() || loading) return;

    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      type: 'user',
      content: inputValue.trim(),
      timestamp: Date.now(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setLoading(true);
    setConversationEnded(false);

    // ÂàõÂª∫ÊµÅÂºèÂìçÂ∫îÊ∂àÊÅØ
    const streamingMessageId = `streaming_${Date.now()}`;
    const streamingMessage: ChatMessage = {
      id: streamingMessageId,
      type: 'streaming',
      content: 'Ê≠£Âú®ÁîüÊàê...',
      timestamp: Date.now(),
      isStreaming: true,
      streamingComplete: false,
    };

    setMessages(prev => [...prev, streamingMessage]);

    try {
      console.log('=== AI Assistant Streaming Request ===');
      console.log('Áî®Êà∑ËæìÂÖ•:', inputValue.trim());
      console.log('AIÊ®°Âºè:', aiMode);
      
      // Ëé∑ÂèñÂΩìÂâçÈ°πÁõÆÁöÑschema‰Ωú‰∏∫‰∏ä‰∏ãÊñá
      const currentSchema = ctx.project.exportSchema('Save' as any);
      console.log('ÂΩìÂâçÈ°πÁõÆschema:', currentSchema);
      
      let streamingContent = '';
      
      const handleStreamEvent = (event: StreamEvent) => {
        console.log('Êî∂Âà∞ÊµÅÂºè‰∫ã‰ª∂:', event);
        
        switch (event.type) {
          case 'start':
            streamingContent = event.message || 'ÂºÄÂßãÁîüÊàê...';
            updateStreamingMessage(streamingMessageId, streamingContent);
            break;
            
          case 'progress':
            // Ê£ÄÊü•ÊòØÂê¶ÊòØËø≠‰ª£ËøáÁ®ã‰∏≠ÁöÑÊµÅÂºèÊñáÊú¨
            if (event.iterationNumber && event.message) {
              // Ëø≠‰ª£ËøáÁ®ã‰∏≠ÁöÑÊµÅÂºèÊñáÊú¨ - ‰ΩøÁî®ËäÇÊµÅÂ§ÑÁêÜÈÅøÂÖçËøáÂ∫¶Êõ¥Êñ∞
              if (event.streaming) {
                // ÊµÅÂºèÊñáÊú¨Á¥ØÁßØÊòæÁ§∫Ôºå‰ΩÜÈôêÂà∂Êõ¥Êñ∞È¢ëÁéá
                const currentTime = Date.now();
                if (currentTime - lastUpdateTimeRef.current > 100) { // 100msËäÇÊµÅ
                  streamingContent += event.message;
                  updateStreamingMessage(streamingMessageId, streamingContent);
                  lastUpdateTimeRef.current = currentTime;
                }
              } else {
                // ÈùûÊµÅÂºèÊ∂àÊÅØÁõ¥Êé•ÊõøÊç¢
                streamingContent = event.message;
                updateStreamingMessage(streamingMessageId, streamingContent);
              }
            } else {
              // ÊôÆÈÄöËøõÂ∫¶Ê∂àÊÅØ - Áõ¥Êé•‰ΩøÁî®ÂÆåÊï¥ÁöÑÊ∂àÊÅØÂÜÖÂÆπ
              streamingContent = event.message || '';
              updateStreamingMessage(streamingMessageId, streamingContent);
            }
            break;
            
          case 'iteration':
            if (event.iterationNumber) {
              // Â¶ÇÊûúÊòØÊµÅÂºèËø≠‰ª£Ê∂àÊÅØÔºåÊ∑ªÂä†Ëø≠‰ª£Ê†áËØÜÂíåÂÆûÈôÖÂÜÖÂÆπ
              if (event.streaming && event.message) {
                // Âú®ÂΩìÂâçÊµÅÂºèÊ∂àÊÅØ‰∏≠Ê∑ªÂä†Ëø≠‰ª£Ê†áËØÜÂíåAIËøîÂõûÁöÑÂÜÖÂÆπ
                // ÈÅøÂÖçÈáçÂ§çÁ¥ØÁßØÔºå‰ΩøÁî®ËäÇÊµÅÂ§ÑÁêÜ
                const newContent = `\n\nüîÑ Á¨¨ ${event.iterationNumber} Ê¨°Ëø≠‰ª£‰ºòÂåñ:\n${event.message}`;
                if (!streamingContent.includes(`Á¨¨ ${event.iterationNumber} Ê¨°Ëø≠‰ª£‰ºòÂåñ`)) {
                  streamingContent += newContent;
                  updateStreamingMessage(streamingMessageId, streamingContent);
                }
              } else {
                // ÈùûÊµÅÂºèËø≠‰ª£Ê∂àÊÅØÔºåÂàõÂª∫Áã¨Á´ãÁöÑËø≠‰ª£Ê∂àÊÅØ
                addIterationMessage(streamingMessageId, {
                  iterationNumber: event.iterationNumber,
                  completed: event.completed || false,
                  hasSchema: event.hasSchema || false,
                  schemaSize: event.schemaSize || 0,
                  reasoning: event.reasoning,
                });
              }
            }
            break;
            
          case 'complete':
            streamingContent += '\n‚úÖ ÁîüÊàêÂÆåÊàê';
            
            // Ê≠£Á°ÆÊèêÂèñschema
            const finalSchema = event.schema || event.result?.schema;
            updateStreamingMessage(streamingMessageId, streamingContent, true, finalSchema, event.result);
            
            // ‰øùÂ≠òÊúÄÁªàÁªìÊûúÔºåÁ≠âÂæÖÂØπËØùÁªìÊùüÂêéÂ∫îÁî®
            if (finalSchema) {
              setPendingSchemas(prev => [...prev, finalSchema]);
            }
            break;
            
          case 'error':
            streamingContent += '\n‚ùå ÁîüÊàêÂ§±Ë¥•: ' + (event.message || event.error);
            updateStreamingMessage(streamingMessageId, streamingContent, true);
            break;
        }
      };
      
      if (aiMode === 'smart-materials') {
        console.log('‰ΩøÁî®Êô∫ËÉΩÁâ©ÊñôÈÄâÊã©ÊµÅÂºèÊ®°Âºè');
        
        const detailedMaterials = await getDetailedMaterials();
        console.log('ËØ¶ÁªÜÁâ©Êñô‰ø°ÊÅØ:', detailedMaterials);
        
        await generateSchemaWithMaterialsStream({
          prompt: inputValue.trim(),
          currentSchema,
          materials: detailedMaterials.map(m => m.name),
        }, handleStreamEvent);
      } else {
        console.log('‰ΩøÁî®Ê†áÂáÜÊµÅÂºèÊ®°Âºè');
        
        const materials = await getAvailableMaterials();
        console.log('ÂèØÁî®Áâ©Êñô:', materials);
        
        await generateSchemaStream({
          prompt: inputValue.trim(),
          currentSchema,
          materials,
        }, handleStreamEvent);
      }
      
    } catch (error) {
      console.error('ÊµÅÂºèAIÁîüÊàêÂ§±Ë¥•:', error);
      
      // Êõ¥Êñ∞ÊµÅÂºèÊ∂àÊÅØÊòæÁ§∫ÈîôËØØ
      updateStreamingMessage(streamingMessageId, '‚ùå ÁîüÊàêÂ§±Ë¥•: ' + (error as Error).message, true);
      
      // ÈôçÁ∫ßÂà∞ÈùûÊµÅÂºèÊ®°Âºè
      try {
        console.log('ÈôçÁ∫ßÂà∞ÈùûÊµÅÂºèÊ®°Âºè');
        let result;
        
        if (aiMode === 'smart-materials') {
          const detailedMaterials = await getDetailedMaterials();
          result = await generateSchemaWithMaterials({
            prompt: inputValue.trim(),
            currentSchema: ctx.project.exportSchema('Save' as any),
            materials: detailedMaterials.map(m => m.name),
          });
        } else {
          const materials = await getAvailableMaterials();
          result = await generateSchema({
            prompt: inputValue.trim(),
            currentSchema: ctx.project.exportSchema('Save' as any),
            materials,
          });
        }
        
        if (result.success) {
          let schema = null;
          if (aiMode === 'smart-materials' && result.result?.schema) {
            schema = result.result.schema;
          } else if (result.schema) {
            schema = result.schema;
          }
          
          if (schema) {
            setPendingSchemas(prev => [...prev, schema]);
            updateStreamingMessage(streamingMessageId, '‚úÖ ‰ΩøÁî®ÈùûÊµÅÂºèÊ®°ÂºèÁîüÊàêÂÆåÊàê', true, schema, result.result);
          }
        } else {
          throw new Error(result.error || 'ÁîüÊàêÂ§±Ë¥•');
        }
      } catch (fallbackError) {
        console.error('ÈôçÁ∫ßÊ®°Âºè‰πüÂ§±Ë¥•:', fallbackError);
        updateStreamingMessage(streamingMessageId, '‚ùå ÊâÄÊúâÁîüÊàêÊñπÂºèÈÉΩÂ§±Ë¥•‰∫Ü', true);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleClearChat = () => {
    setMessages([]);
    setPendingSchemas([]);
    setConversationEnded(false);
  };



  const formatTime = (timestamp: number) => {
    return new Date(timestamp).toLocaleTimeString('zh-CN', {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <>
      <Button 
        type="secondary"
        onClick={() => setVisible(true)}
        style={{ marginRight: 8 }}
      >
        AIÂä©Êâã
      </Button>
      
      <Dialog
        visible={visible}
        onClose={() => setVisible(false)}
        title="AIÂä©Êâã - Êô∫ËÉΩÁîüÊàêÈ°µÈù¢"
        style={{ width: 600, height: 500 }}
        footer={null}
        className="ai-assistant-dialog"
      >
        <div className="ai-chat-container">
          <div className="ai-chat-header">
            <div className="ai-chat-header-content">
              <span>ÊèèËø∞ÊÇ®ÊÉ≥Ë¶ÅÁöÑÈ°µÈù¢ÔºåAIÂ∞Ü‰∏∫ÊÇ®ÁîüÊàêÂØπÂ∫îÁöÑÁïåÈù¢</span>
              <Button 
                text 
                size="medium" 
                onClick={handleClearChat}
                disabled={messages.length === 0}
              >
                Ê∏ÖÁ©∫ÂØπËØù
              </Button>
            </div>
            
            <Divider style={{ margin: '8px 0' }} />
            
            <div className="ai-mode-selector">
               <span style={{ marginRight: 12, fontSize: 13, color: '#666' }}>AIÊ®°ÂºèÔºö</span>
               <Radio.Group 
                 value={aiMode} 
                 onChange={(value) => setAiMode(value as AIMode)}
                 disabled={loading}
                 size="medium"
               >
                 <Radio value="standard">Ê†áÂáÜÊ®°Âºè</Radio>
                 <Radio value="smart-materials">Êô∫ËÉΩÁâ©ÊñôÈÄâÊã©</Radio>
               </Radio.Group>
             </div>
            
            <div className="ai-mode-description">
              {aiMode === 'standard' ? (
                <span style={{ fontSize: 12, color: '#999' }}>
                  ‰ΩøÁî®È¢ÑËÆæÁâ©ÊñôÂ∫ìÁîüÊàêÈ°µÈù¢
                </span>
              ) : (
                <span style={{ fontSize: 12, color: '#999' }}>
                  AIÊô∫ËÉΩÂàÜÊûêÂπ∂ÈÄâÊã©ÊúÄÈÄÇÂêàÁöÑÁâ©ÊñôÁªÑÂêà
                </span>
              )}
            </div>

            {/* ÂØπËØùÁªìÊùüÂíåÂ∫îÁî®ÊåâÈíÆ */}
            {pendingSchemas.length > 0 && !conversationEnded && (
              <div style={{ marginTop: 8 }}>
                <Button 
                  type="primary" 
                  size="small"
                  onClick={endConversationAndApply}
                  disabled={loading}
                >
                  ÁªìÊùüÂØπËØùÂπ∂Â∫îÁî®Âà∞ÁºñËæëÂô®
                </Button>
                <span style={{ marginLeft: 8, fontSize: 12, color: '#666' }}>
                  ({pendingSchemas.length} ‰∏™ÂæÖÂ∫îÁî®ÁöÑÁªìÊûú)
                </span>
              </div>
            )}
          </div>
          
          <div className="ai-chat-messages">
            {messages.length === 0 && (
              <div className="ai-chat-welcome">
                <p>üëã ÊÇ®Â•ΩÔºÅÊàëÊòØAIÂä©Êâã</p>
                <p>ËØ∑ÂëäËØâÊàëÊÇ®ÊÉ≥Ë¶ÅÂàõÂª∫‰ªÄ‰πàÊ†∑ÁöÑÈ°µÈù¢Ôºå‰æãÂ¶ÇÔºö</p>
                <ul>
                  <li>"ÂàõÂª∫‰∏Ä‰∏™Áî®Êà∑ÁôªÂΩïÈ°µÈù¢"</li>
                  <li>"ÁîüÊàê‰∏Ä‰∏™ÂïÜÂìÅÂàóË°®È°µÈù¢ÔºåÂåÖÂê´ÊêúÁ¥¢ÂíåÁ≠õÈÄâÂäüËÉΩ"</li>
                  <li>"Âà∂‰Ωú‰∏Ä‰∏™Êï∞ÊçÆÁªüËÆ°‰ª™Ë°®Êùø"</li>
                </ul>
                <p style={{ fontSize: 12, color: '#999', marginTop: 16 }}>
                  üí° ÊèêÁ§∫ÔºöAI‰ºö‰ª•ÊµÅÂºèÊñπÂºèÂ±ïÁ§∫ÁîüÊàêËøáÁ®ãÔºåÂè™ÊúâÂú®ÊÇ®ÁÇπÂáª"ÁªìÊùüÂØπËØùÂπ∂Â∫îÁî®Âà∞ÁºñËæëÂô®"ÂêéÔºåÁªìÊûúÊâç‰ºöÂ∫îÁî®Âà∞È°µÈù¢ÁºñËæëÂô®‰∏≠„ÄÇ
                </p>
              </div>
            )}
            
            {messages.map((message) => (
              <div 
                key={message.id} 
                className={`ai-chat-message ${message.type}`}
              >
                <div className="ai-chat-message-content">
                  <div className="ai-chat-message-text">
                    {message.content}
                    {message.type === 'streaming' && message.isStreaming && !message.streamingComplete && (
                      <span className="streaming-indicator">...</span>
                    )}
                    {/* ÊòæÁ§∫ÊúÄÁªàÁöÑschemaÂÜÖÂÆπ */}
                    {message.type === 'streaming' && message.streamingComplete && message.finalSchema && (
                      <div style={{ marginTop: 12, padding: 8, backgroundColor: '#f5f5f5', borderRadius: 4 }}>
                        <div style={{ fontSize: 12, color: '#666', marginBottom: 4 }}>üìã ÁîüÊàêÁöÑSchema:</div>
                        <pre style={{ fontSize: 11, color: '#333', whiteSpace: 'pre-wrap', maxHeight: 200, overflow: 'auto' }}>
                          {JSON.stringify(message.finalSchema, null, 2)}
                        </pre>
                      </div>
                    )}
                    {message.type === 'iteration' && message.iterationData && (
                      <div style={{ marginTop: 8, fontSize: 12, color: '#666' }}>
                        <div>üìä SchemaÂ§ßÂ∞è: {message.iterationData.schemaSize} Â≠óÁ¨¶</div>
                        <div>‚úÖ Áä∂ÊÄÅ: {message.iterationData.hasSchema ? 'Â∑≤ÁîüÊàêSchema' : 'Êú™ÁîüÊàêSchema'}</div>
                        {message.iterationData.reasoning && (
                          <div style={{ marginTop: 4, fontStyle: 'italic' }}>
                            üí≠ Êé®ÁêÜ: {message.iterationData.reasoning}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                  <div className="ai-chat-message-time">
                    {formatTime(message.timestamp)}
                  </div>
                </div>
              </div>
            ))}
            
            {loading && (
              <div className="ai-chat-message assistant">
                <div className="ai-chat-message-content">
                  <div className="ai-chat-loading">
                    <Loading size="medium" />
                    <span>AIÊ≠£Âú®‰∏∫ÊÇ®ÁîüÊàêÈ°µÈù¢...</span>
                  </div>
                </div>
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>

          <div className="ai-chat-input">
            <Input.TextArea
              value={inputValue}
              onChange={setInputValue}
              onKeyPress={handleKeyPress}
              placeholder="ÊèèËø∞ÊÇ®ÊÉ≥Ë¶ÅÁöÑÈ°µÈù¢..."
              rows={3}
              disabled={loading}
            />
            <div className="ai-chat-input-actions">
              <Button 
              type="primary" 
              size="medium"
              onClick={handleSendMessage}
              loading={loading}
              disabled={!inputValue.trim() || loading}
            >
              ÂèëÈÄÅ
            </Button>
            </div>
          </div>
        </div>
      </Dialog>
    </>
  );
};

export default AIAssistant;